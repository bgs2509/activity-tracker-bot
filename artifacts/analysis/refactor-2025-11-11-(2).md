# Code Similarity Refactoring Plan
**Date:** 2025-11-11
**Status:** Planning
**Estimated Total Time:** 110 minutes
**Estimated Code Savings:** ~120 lines + improved maintainability

---

## Executive Summary

Based on comprehensive code similarity analysis of 203 Python files in the activity-tracker-bot project, this plan addresses the top priority refactoring opportunities. The analysis identified 15 groups of similar functions, with 3 critical areas requiring immediate attention to eliminate code duplication and establish single sources of truth.

**Key Findings:**
- âœ… **Exact duplicate found:** `get_user_and_settings()` exists in 2 locations (100% identical)
- âš ï¸ **Time validation logic duplicated** across handlers and services (~82% similar)
- ğŸ”„ **String validation patterns repeated** in multiple validators (~70% similar)
- ğŸ“Š **~120 lines of code** can be eliminated through targeted refactoring

**Architecture Assessment:**
- Most similarities are intentional patterns (logging, error handling, API structure)
- Recent `shared.py` module demonstrates excellent DRY refactoring
- BaseRepository pattern is well-implemented
- Service layer architecture is sound

---

## TODO Plan

### ğŸ”´ CRITICAL PRIORITY (Immediate Action Required)

#### âœ… Task 1: Refactor Duplicate `get_user_and_settings()` Helper
**Status:** â¸ï¸ Pending
**Priority:** P0 - Critical
**Estimated Time:** 15 minutes
**Code Savings:** ~50 lines

**Problem:**
Exact duplicate function exists in two locations:
- `services/tracker_activity_bot/src/api/handlers/settings/helpers.py:14-64`
- `services/tracker_activity_bot/src/api/handlers/poll/helpers.py:51-101`

**Implementation Steps:**

1. **Create shared utilities module**
   - Create file: `services/tracker_activity_bot/src/application/utils/user_helpers.py`
   - Add module docstring and imports
   - Copy function from one location (preserve docstring and type hints)

2. **Update imports in both handler modules**
   - `handlers/settings/helpers.py`: Add import
   - `handlers/poll/helpers.py`: Add import

3. **Remove duplicate implementations**
   - Delete function from `settings/helpers.py`
   - Delete function from `poll/helpers.py`

4. **Verify no functionality changes**
   - Run unit tests for settings handlers
   - Run unit tests for poll handlers
   - Check integration tests pass

**Code Example:**
```python
# services/tracker_activity_bot/src/application/utils/user_helpers.py
"""User-related helper utilities for fetching user data and settings."""

from typing import Optional, Tuple
import logging

from infrastructure.service_container import ServiceContainer

logger = logging.getLogger(__name__)


async def get_user_and_settings(
    telegram_id: int,
    services: ServiceContainer
) -> Tuple[Optional[dict], Optional[dict]]:
    """
    Fetch user by telegram_id and their settings.

    Args:
        telegram_id: User's Telegram ID
        services: Service container with HTTP clients

    Returns:
        Tuple of (user_dict, settings_dict) or (None, None) if not found

    Example:
        >>> user, settings = await get_user_and_settings(123456, services)
        >>> if user and settings:
        ...     print(f"User: {user['username']}")
    """
    # ... (copy existing implementation)
```

**Testing Strategy:**
- [ ] Unit tests for `user_helpers.py`
- [ ] Existing tests for settings handlers still pass
- [ ] Existing tests for poll handlers still pass
- [ ] Manual smoke test: settings menu works
- [ ] Manual smoke test: poll flow works

**Success Criteria:**
- âœ… Single source of truth for `get_user_and_settings()`
- âœ… All tests pass
- âœ… No behavior changes
- âœ… ~50 lines of duplicate code removed

---

### ğŸŸ¡ HIGH PRIORITY (Near-term)

#### âœ… Task 2: Consolidate Time Validation Logic
**Status:** â¸ï¸ Pending
**Priority:** P1 - High
**Estimated Time:** 30 minutes
**Code Savings:** ~40 lines + single source of truth for business rules

**Problem:**
Time validation logic is duplicated in two places:
- **Bot handlers:** `handlers/activity/helpers.py` - `validate_start_time()`, `validate_end_time()`
- **Data service:** `services/data_postgres_api/src/application/services/activity_service.py` - inline validation

**Current Issues:**
1. Business rules exist in two places (violation of DRY)
2. Changes to validation logic must be synchronized manually
3. Handler-level validation uses different return patterns than service-level

**Implementation Steps:**

1. **Create centralized time validation module**
   - Create: `services/data_postgres_api/src/application/validators/time_validators.py`
   - Move validation logic from service layer
   - Ensure comprehensive validation rules

2. **Define validation functions**
   ```python
   def validate_start_time(start_time: datetime) -> None:
       """Raises ValueError if start_time is invalid."""

   def validate_end_time(end_time: datetime, start_time: datetime) -> None:
       """Raises ValueError if end_time is invalid relative to start_time."""

   def validate_activity_duration(start_time: datetime, end_time: datetime) -> None:
       """Raises ValueError if duration exceeds limits."""
   ```

3. **Update service layer to use validators**
   - Import validators in `activity_service.py`
   - Replace inline validation with validator calls
   - Preserve error messages

4. **Update bot handlers to use validators**
   - Import validators in `handlers/activity/helpers.py`
   - Replace `validate_start_time()` with service validator
   - Replace `validate_end_time()` with service validator
   - Handle ValueError exceptions and convert to user messages

5. **Update error handling pattern**
   ```python
   # In bot handlers:
   try:
       validate_start_time(start_time)
       return None  # No error
   except ValueError as e:
       return str(e)  # Return error message to user
   ```

**Code Example:**
```python
# services/data_postgres_api/src/application/validators/time_validators.py
"""Time validation utilities for activity operations."""

from datetime import datetime, timezone


def validate_start_time(start_time: datetime) -> None:
    """
    Validate that start_time is valid for an activity.

    Args:
        start_time: Activity start time (must be timezone-aware)

    Raises:
        ValueError: If start_time is in the future

    Example:
        >>> validate_start_time(datetime.now(timezone.utc))  # OK
        >>> validate_start_time(datetime.now(timezone.utc) + timedelta(hours=1))
        ValueError: Start time cannot be in the future
    """
    if not start_time.tzinfo:
        raise ValueError("Start time must be timezone-aware")

    now_utc = datetime.now(timezone.utc)
    if start_time > now_utc:
        raise ValueError("Start time cannot be in the future")


def validate_end_time(end_time: datetime, start_time: datetime) -> None:
    """
    Validate that end_time is valid relative to start_time.

    Args:
        end_time: Activity end time (must be timezone-aware)
        start_time: Activity start time (must be timezone-aware)

    Raises:
        ValueError: If end_time is invalid

    Example:
        >>> start = datetime.now(timezone.utc) - timedelta(hours=1)
        >>> end = datetime.now(timezone.utc)
        >>> validate_end_time(end, start)  # OK
    """
    if not end_time.tzinfo or not start_time.tzinfo:
        raise ValueError("Times must be timezone-aware")

    if end_time <= start_time:
        raise ValueError("End time must be after start time")

    now_utc = datetime.now(timezone.utc)
    if end_time > now_utc:
        raise ValueError("End time cannot be in the future")


def validate_activity_duration(
    start_time: datetime,
    end_time: datetime,
    max_hours: int = 24
) -> None:
    """
    Validate that activity duration is within acceptable limits.

    Args:
        start_time: Activity start time
        end_time: Activity end time
        max_hours: Maximum allowed duration in hours (default: 24)

    Raises:
        ValueError: If duration exceeds max_hours

    Example:
        >>> start = datetime.now(timezone.utc) - timedelta(hours=2)
        >>> end = datetime.now(timezone.utc)
        >>> validate_activity_duration(start, end)  # OK
    """
    duration = end_time - start_time
    if duration.total_seconds() / 3600 > max_hours:
        raise ValueError(f"Activity duration cannot exceed {max_hours} hours")
```

**Testing Strategy:**
- [ ] Unit tests for new `time_validators.py` module
  - Test valid times pass
  - Test future start time raises ValueError
  - Test end_time before start_time raises ValueError
  - Test excessive duration raises ValueError
  - Test timezone-naive datetimes raise ValueError
- [ ] Update existing service tests to expect new error messages
- [ ] Update existing handler tests to use new validation flow
- [ ] Integration tests for activity creation with invalid times

**Success Criteria:**
- âœ… Single source of truth for time validation business rules
- âœ… All validation logic in validator module
- âœ… Both bot and service use same validators
- âœ… All tests pass
- âœ… ~40 lines of duplicate code removed

---

### ğŸŸ¢ MEDIUM PRIORITY (When Possible)

#### âœ… Task 3: Extract Common String Length Validator
**Status:** â¸ï¸ Pending
**Priority:** P2 - Medium
**Estimated Time:** 20 minutes
**Code Savings:** ~30 lines

**Problem:**
String length validation is repeated across multiple validators:
- `handlers/categories/helpers.py` - `validate_category_name()`, `validate_emoji()`
- `handlers/activity/shared.py` - `validate_description()`

All follow same pattern: check min/max length, return error message or None.

**Implementation Steps:**

1. **Create validators utility module**
   - Create: `services/tracker_activity_bot/src/application/utils/validators.py`
   - Add comprehensive docstring

2. **Implement generic string length validator**
   ```python
   def validate_string_length(
       value: str,
       min_length: int,
       max_length: int,
       field_name_ru: str,
       allow_empty: bool = False
   ) -> str | None:
       """
       Validate string length constraints.

       Returns:
           None if valid, error message string if invalid
       """
   ```

3. **Update existing validators to use helper**
   - Update `validate_category_name()` to call helper
   - Update `validate_emoji()` to call helper
   - Update `validate_description()` to call helper

4. **Preserve existing error message format**
   - Maintain emoji prefix: "âš ï¸"
   - Maintain Russian messages for user interface
   - Ensure exact same messages for backward compatibility

**Code Example:**
```python
# services/tracker_activity_bot/src/application/utils/validators.py
"""Common validation utilities for user input."""


def validate_string_length(
    value: str,
    min_length: int,
    max_length: int,
    field_name_ru: str,
    allow_empty: bool = False
) -> str | None:
    """
    Validate that a string meets length constraints.

    Args:
        value: String to validate
        min_length: Minimum allowed length (inclusive)
        max_length: Maximum allowed length (inclusive)
        field_name_ru: Russian field name for error messages (e.g., "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸")
        allow_empty: Whether empty strings are allowed (default: False)

    Returns:
        None if validation passes, error message string if validation fails

    Example:
        >>> validate_string_length("test", 3, 10, "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ")
        None
        >>> validate_string_length("ab", 3, 10, "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ")
        'âš ï¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ 3 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²'
        >>> validate_string_length("a" * 20, 3, 10, "ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ")
        'âš ï¸ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ 10 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²'
    """
    if not value and not allow_empty:
        return f"âš ï¸ {field_name_ru} Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼"

    if len(value) < min_length:
        return f"âš ï¸ {field_name_ru} Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼ÑƒĞ¼ {min_length} ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²"

    if len(value) > max_length:
        return f"âš ï¸ {field_name_ru} Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ¾ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¼Ğ°ĞºÑĞ¸Ğ¼ÑƒĞ¼ {max_length} ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²"

    return None


# Usage in existing validators:
def validate_category_name(name: str) -> str | None:
    """Validate category name length and format."""
    return validate_string_length(
        value=name,
        min_length=1,
        max_length=50,
        field_name_ru="ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸"
    )


def validate_emoji(emoji: str) -> str | None:
    """Validate emoji is a single character."""
    return validate_string_length(
        value=emoji,
        min_length=1,
        max_length=4,  # Some emoji are multi-byte
        field_name_ru="Ğ­Ğ¼Ğ¾Ğ´Ğ·Ğ¸"
    )


def validate_description(description: str) -> str | None:
    """Validate activity description."""
    return validate_string_length(
        value=description,
        min_length=1,
        max_length=500,
        field_name_ru="ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ğ¸"
    )
```

**Testing Strategy:**
- [ ] Unit tests for `validate_string_length()`
  - Test valid strings pass
  - Test too short returns error
  - Test too long returns error
  - Test empty string handling
  - Test error message format
- [ ] Verify existing validator tests still pass
- [ ] Manual test: category creation with invalid name
- [ ] Manual test: activity creation with invalid description

**Success Criteria:**
- âœ… Common validator reduces duplication
- âœ… All existing validators use helper
- âœ… Error messages unchanged (backward compatible)
- âœ… All tests pass
- âœ… ~30 lines of duplicate code removed

---

#### âœ… Task 4: Extract Regex Patterns to Constants (time_parser)
**Status:** â¸ï¸ Pending
**Priority:** P2 - Medium
**Estimated Time:** 25 minutes
**Code Savings:** Improved maintainability, easier to modify patterns

**Problem:**
Similar regex patterns are duplicated across parsing functions in `time_parser.py`:
- `parse_time_input()` - patterns for time formats
- `parse_duration()` - patterns for duration formats
- `parse_period()` - patterns for period keywords

**Implementation Steps:**

1. **Create constants section at top of `time_parser.py`**
   ```python
   # Time format patterns
   MINUTES_PATTERN = r"^(\d+)(Ğ¼|min)?$"
   HOURS_PATTERN = r"^(\d+)(Ñ‡|h|hour|hours)?$"
   EXACT_TIME_PATTERN = r"^(\d{1,2})[:\-\.](\d{2})$"

   # Period keywords
   PERIOD_TODAY_KEYWORDS = ["ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ", "today"]
   PERIOD_YESTERDAY_KEYWORDS = ["Ğ²Ñ‡ĞµÑ€Ğ°", "yesterday"]
   ...
   ```

2. **Replace inline regex strings with constants**
   - Update `parse_time_input()` to use constants
   - Update `parse_duration()` to use constants
   - Update `parse_period()` to use constants

3. **Add docstring section documenting patterns**
   ```python
   """
   Time Parsing Patterns
   ---------------------
   MINUTES_PATTERN: Matches "30", "30Ğ¼", "30min"
   HOURS_PATTERN: Matches "2", "2Ñ‡", "2h", "2hours"
   ...
   """
   ```

4. **Consider extracting common parsing helpers**
   ```python
   def _parse_minutes(time_str: str) -> int | None:
       """Extract minutes from string using MINUTES_PATTERN."""

   def _parse_hours(time_str: str) -> int | None:
       """Extract hours from string using HOURS_PATTERN."""
   ```

**Code Example:**
```python
# services/tracker_activity_bot/src/application/utils/time_parser.py
"""Time parsing utilities for natural language time input."""

import re
from datetime import datetime, timedelta
from typing import Optional
import pytz

# ============================================================================
# Regex Patterns
# ============================================================================

# Duration patterns
MINUTES_PATTERN = re.compile(r"^(\d+)(Ğ¼|min)?$", re.IGNORECASE)
HOURS_PATTERN = re.compile(r"^(\d+)(Ñ‡|h|hour|hours)?$", re.IGNORECASE)
HOURS_MINUTES_PATTERN = re.compile(r"^(\d+)(Ñ‡|h)(\d+)(Ğ¼|min)?$", re.IGNORECASE)

# Exact time patterns
EXACT_TIME_COLON = re.compile(r"^(\d{1,2}):(\d{2})$")
EXACT_TIME_DASH = re.compile(r"^(\d{1,2})-(\d{2})$")
EXACT_TIME_DOT = re.compile(r"^(\d{1,2})\.(\d{2})$")

# Keywords
NOW_KEYWORDS = ["ÑĞµĞ¹Ñ‡Ğ°Ñ", "now"]
TODAY_KEYWORDS = ["ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ", "today"]
YESTERDAY_KEYWORDS = ["Ğ²Ñ‡ĞµÑ€Ğ°", "yesterday"]
WEEK_KEYWORDS = ["Ğ½ĞµĞ´ĞµĞ»Ñ", "week"]
MONTH_KEYWORDS = ["Ğ¼ĞµÑÑÑ†", "month"]

# ============================================================================
# Helper Functions
# ============================================================================

def _parse_minutes(time_str: str) -> Optional[int]:
    """
    Extract minutes from string.

    Args:
        time_str: String like "30", "30Ğ¼", "30min"

    Returns:
        Integer minutes or None if no match

    Example:
        >>> _parse_minutes("30Ğ¼")
        30
        >>> _parse_minutes("45min")
        45
    """
    match = MINUTES_PATTERN.match(time_str)
    if match:
        return int(match.group(1))
    return None


def _parse_hours(time_str: str) -> Optional[int]:
    """
    Extract hours from string.

    Args:
        time_str: String like "2", "2Ñ‡", "2h"

    Returns:
        Integer hours or None if no match

    Example:
        >>> _parse_hours("2Ñ‡")
        2
        >>> _parse_hours("3hours")
        3
    """
    match = HOURS_PATTERN.match(time_str)
    if match:
        return int(match.group(1))
    return None


# ============================================================================
# Public API
# ============================================================================

def parse_time_input(time_str: str, user_timezone: str) -> datetime:
    """Parse natural language time input to datetime."""
    time_str = time_str.strip().lower()

    # Check for "now" keywords
    if time_str in NOW_KEYWORDS:
        return datetime.now(pytz.timezone(user_timezone))

    # Try minutes ago
    minutes = _parse_minutes(time_str)
    if minutes is not None:
        # ... implementation

    # Try hours ago
    hours = _parse_hours(time_str)
    if hours is not None:
        # ... implementation

    # Try exact time
    for pattern in [EXACT_TIME_COLON, EXACT_TIME_DASH, EXACT_TIME_DOT]:
        match = pattern.match(time_str)
        if match:
            # ... implementation

    raise ValueError(f"Unable to parse time: {time_str}")
```

**Testing Strategy:**
- [ ] Run existing unit tests for `time_parser.py`
- [ ] Ensure no behavior changes
- [ ] Add tests for new helper functions if created
- [ ] Manual test: various time input formats

**Success Criteria:**
- âœ… All regex patterns extracted to constants
- âœ… Patterns documented in module docstring
- âœ… All tests pass with no behavior changes
- âœ… Easier to modify patterns in the future

---

### âšª LOW PRIORITY (Consider for Future)

#### âœ… Task 5: Create Logging Decorators for Repository Operations
**Status:** â¸ï¸ Pending
**Priority:** P3 - Low
**Estimated Time:** 45 minutes
**Code Savings:** Consistency improvement, ~20 lines per repository

**Problem:**
Repository methods follow consistent logging pattern but code is repeated:
```python
logger.debug("Retrieving X", extra={...})
try:
    # operation
    logger.debug("X found/created/updated", extra={...})
except Exception as e:
    logger.error("Error with X", extra={...}, exc_info=True)
    raise
```

**Implementation Approach:**
```python
@log_repository_operation(operation="read", entity_type="User")
async def get_by_telegram_id(self, telegram_id: int) -> User | None:
    # Core logic only, logging handled by decorator
```

**Benefits:**
- Consistent logging across all repositories
- Reduced boilerplate in repository methods
- Centralized logging format changes

**Considerations:**
- Decorator complexity vs. explicit logging clarity
- May reduce readability for new developers
- BaseRepository already abstracts common operations

**Recommendation:** Consider only if logging format changes frequently. Current explicit approach is clear and maintainable.

---

#### âœ… Task 6: Create Navigation Button Helpers for Keyboards
**Status:** â¸ï¸ Pending
**Priority:** P3 - Low
**Estimated Time:** 30 minutes
**Code Savings:** ~10 lines per keyboard builder

**Problem:**
Navigation buttons are repeated across keyboard builders:
```python
InlineKeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")
InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data="cancel")
InlineKeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data="back")
```

**Implementation Approach:**
```python
# keyboards/common.py
def get_main_menu_button() -> InlineKeyboardButton:
    return InlineKeyboardButton(text="ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")

def get_cancel_button() -> InlineKeyboardButton:
    return InlineKeyboardButton(text="âŒ ĞÑ‚Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ", callback_data="cancel")

def get_back_button(callback_data: str = "back") -> InlineKeyboardButton:
    return InlineKeyboardButton(text="ğŸ”™ ĞĞ°Ğ·Ğ°Ğ´", callback_data=callback_data)
```

**Benefits:**
- Consistent button text and emoji
- Easy to update all buttons at once
- Centralized callback_data values

**Considerations:**
- Each keyboard is specialized and may need custom buttons
- Extraction may reduce clarity (text/callback hidden in function)
- Current explicit approach shows all buttons at a glance

**Recommendation:** Consider only if button text/callbacks change frequently. Current approach is explicit and clear.

---

#### âœ… Task 7: Add FSM State Validation Helpers
**Status:** â¸ï¸ Pending
**Priority:** P3 - Low
**Estimated Time:** 35 minutes
**Code Savings:** ~15 lines per FSM handler

**Problem:**
FSM handlers repeat state data validation pattern:
```python
data = await state.get_data()
if "required_field" not in data:
    await message.answer("ĞÑˆĞ¸Ğ±ĞºĞ°: Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğµ")
    await state.clear()
    return
```

**Implementation Approach:**
```python
async def require_state_fields(
    state: FSMContext,
    required_fields: list[str],
    error_handler: Callable
) -> dict | None:
    """Get state data and validate required fields exist."""
    data = await state.get_data()

    for field in required_fields:
        if field not in data:
            await error_handler(f"ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ¿Ğ¾Ğ»Ğµ: {field}")
            await state.clear()
            return None

    return data
```

**Benefits:**
- Consistent state validation across handlers
- Automatic state clearing on validation failure
- Less boilerplate in FSM handlers

**Considerations:**
- FSM handlers have different error handling needs
- Generic helper may not fit all cases
- Current explicit approach shows validation clearly

**Recommendation:** Consider only if adding many new FSM handlers. Current approach is explicit and handles unique error cases well.

---

## Implementation Order

Recommended execution order by priority and dependencies:

```
Phase 1: Critical Fixes (Day 1)
â”œâ”€ Task 1: get_user_and_settings() refactor (15 min)
â””â”€ âœ“ Run tests, verify no regressions

Phase 2: High Priority (Day 1-2)
â”œâ”€ Task 2: Time validation consolidation (30 min)
â””â”€ âœ“ Run tests, verify validation works correctly

Phase 3: Medium Priority (Day 2)
â”œâ”€ Task 3: String length validator (20 min)
â”œâ”€ Task 4: Regex patterns extraction (25 min)
â””â”€ âœ“ Run tests, verify no behavior changes

Phase 4: Low Priority (Future)
â”œâ”€ Task 5: Logging decorators (evaluate need first)
â”œâ”€ Task 6: Button helpers (evaluate need first)
â””â”€ Task 7: FSM helpers (evaluate need first)
```

---

## Testing Strategy

### Test Levels

1. **Unit Tests**
   - Test each new utility function in isolation
   - Verify edge cases and error conditions
   - Ensure backward-compatible error messages

2. **Integration Tests**
   - Test complete flows using refactored code
   - Verify settings handlers work end-to-end
   - Verify poll handlers work end-to-end
   - Verify activity creation with validation

3. **Manual Testing**
   - Navigate through bot UI testing refactored paths
   - Try invalid inputs to verify validation messages
   - Verify no changes in user-facing behavior

### Test Commands

```bash
# Run all tests
make test-all-docker

# Run specific test suites
docker compose run --rm tracker_activity_bot pytest tests/unit/handlers/
docker compose run --rm tracker_activity_bot pytest tests/integration/

# Run tests for specific modules
docker compose run --rm tracker_activity_bot pytest tests/unit/utils/test_user_helpers.py
docker compose run --rm data_postgres_api pytest tests/unit/validators/
```

### Regression Checks

After each task:
- [ ] All existing tests still pass
- [ ] No new linting errors
- [ ] No new type checking errors
- [ ] Coverage does not decrease
- [ ] Manual smoke tests pass

---

## Metrics and Success Criteria

### Code Quality Metrics

```
Before Refactoring:
â”œâ”€ Duplicate code blocks: 3 critical areas
â”œâ”€ Similar functions: 15 groups identified
â”œâ”€ Repeated validation logic: 5 instances
â””â”€ Lines of duplication: ~120 lines

After Refactoring (Tasks 1-4):
â”œâ”€ Duplicate code blocks: 0 in critical areas
â”œâ”€ Shared utilities: 3 new modules
â”œâ”€ Single source of truth: validation, user helpers, string validators
â””â”€ Lines saved: ~120 lines
â””â”€ Maintainability: â†‘ High (centralized logic)

Code Duplication by Tool (jscpd):
â”œâ”€ Before: ~8.5% duplication
â””â”€ Target: <10% (maintain), <8% (improve)
```

### Time Investment vs. Benefit

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task                           â”‚ Time     â”‚ Code Saved  â”‚ Benefit        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. get_user_and_settings       â”‚  15 min  â”‚  ~50 lines  â”‚ Critical       â”‚
â”‚ 2. Time validation             â”‚  30 min  â”‚  ~40 lines  â”‚ High           â”‚
â”‚ 3. String validators           â”‚  20 min  â”‚  ~30 lines  â”‚ Medium         â”‚
â”‚ 4. Regex patterns              â”‚  25 min  â”‚  Qualityâ†‘   â”‚ Medium         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Total (Priority 1-2)           â”‚  90 min  â”‚ ~120 lines  â”‚ Critical+High  â”‚
â”‚ Total (All Medium)             â”‚ 110 min  â”‚ ~120 lines  â”‚ All immediate  â”‚
â”‚ Future tasks                   â”‚ 110 min  â”‚  ~45 lines  â”‚ Evaluate need  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Success Criteria

**Task 1-2 (Critical/High):**
- âœ… Zero duplicate helper functions
- âœ… Single source of truth for time validation
- âœ… All tests pass (>95% coverage maintained)
- âœ… No user-facing behavior changes
- âœ… Deployment successful to production

**Task 3-4 (Medium):**
- âœ… Common validators reduce duplication
- âœ… Regex patterns are maintainable
- âœ… Documentation is clear
- âœ… All tests pass

**Task 5-7 (Low):**
- âš ï¸ Evaluate necessity before implementing
- âš ï¸ Consider if patterns emerge requiring abstraction
- âš ï¸ Balance abstraction vs. clarity

---

## Risk Assessment and Mitigation

### Risks

1. **Breaking Changes in Validators**
   - Risk: Error message changes break UI expectations
   - Mitigation: Preserve exact error messages, add backward compatibility tests

2. **Import Cycles**
   - Risk: Creating shared utilities may introduce circular imports
   - Mitigation: Keep utilities in application layer, services import from utils (one direction)

3. **Test Failures**
   - Risk: Tests may depend on specific implementation details
   - Mitigation: Run full test suite after each change, fix tests as needed

4. **Merge Conflicts**
   - Risk: Refactoring may conflict with ongoing feature work
   - Mitigation: Coordinate with team, create feature branch, merge quickly

### Mitigation Strategies

```
Strategy 1: Incremental Changes
â”œâ”€ Complete one task fully before moving to next
â”œâ”€ Run tests after each task
â””â”€ Commit after each successful task

Strategy 2: Feature Branch
â”œâ”€ Create: refactor/code-similarity-2025-11-11
â”œâ”€ Make all changes in branch
â”œâ”€ Request code review before merge
â””â”€ Merge to master when approved

Strategy 3: Backward Compatibility
â”œâ”€ Preserve all existing function signatures
â”œâ”€ Maintain exact error messages
â”œâ”€ Add deprecation warnings if removing functions
â””â”€ Update documentation

Strategy 4: Rollback Plan
â”œâ”€ Keep git history clean (one task per commit)
â”œâ”€ Tag before starting: refactor-baseline
â”œâ”€ Can revert individual commits if needed
â””â”€ Can reset to baseline if major issues
```

---

## Documentation Updates

After completing refactoring:

1. **Update API Documentation**
   - Document new utility modules
   - Add examples for validators
   - Update import paths in examples

2. **Update Architecture Docs**
   - Note centralized validation approach
   - Document utility module organization
   - Add decision records for refactoring choices

3. **Update Contributing Guide**
   - Reference shared utilities when adding validators
   - Explain when to use common helpers vs. custom logic
   - Add examples of good practices

4. **Code Comments**
   - Add docstrings to all new utilities
   - Include usage examples
   - Note migration from old locations (for git history)

---

## Follow-up Actions

After completing this refactoring plan:

1. **Monitor Production**
   - Watch logs for validation errors
   - Monitor error rates
   - Check user reports

2. **Update CI/CD**
   - Ensure code duplication gates pass (<10%)
   - Verify complexity metrics don't increase
   - Check test coverage maintained

3. **Team Training**
   - Share refactoring results with team
   - Update onboarding docs
   - Document when to use utilities

4. **Plan Next Phase**
   - Review low-priority tasks (5-7)
   - Evaluate if patterns emerged requiring abstraction
   - Schedule follow-up refactoring if needed

---

## References

- **Original Analysis:** `artifacts/analysis/refactor-2025-11-11-(1).md` (if exists)
- **Code Similarity Report:** Created 2025-11-11
- **Improvement Plan:** `.ai-framework/docs/contributing/improvement-plans/2025-01-dry-kiss-yagni-enforcement.md`
- **DRY Principles Guide:** `.ai-framework/docs/principles/dry.md`

---

## Appendix: Alternative Approaches Considered

### Alternative 1: Create Mega-Utility Module
**Rejected because:**
- Would create god object anti-pattern
- Harder to navigate and find utilities
- Violates single responsibility principle

**Chosen approach:** Multiple focused utility modules (user_helpers, validators, etc.)

### Alternative 2: Use Inheritance for Validators
**Rejected because:**
- Validators are simple functions, not objects
- Inheritance adds complexity without benefit
- Harder to compose validators

**Chosen approach:** Simple functions that can be composed

### Alternative 3: Delay Refactoring Until More Duplication Emerges
**Rejected because:**
- Exact duplicates exist now (100% similarity)
- Technical debt compounds over time
- Team is already aware of duplication

**Chosen approach:** Refactor critical items now, evaluate low-priority items later

---

## Status Updates

| Date | Status | Notes |
|------|--------|-------|
| 2025-11-11 | Planning | Initial plan created |
| TBD | In Progress | Task 1 started |
| TBD | Completed | All critical/high tasks done |

---

**Plan Version:** 1.0
**Last Updated:** 2025-11-11
**Next Review:** After Task 2 completion
